import logging
import pathlib
import sys

import paramiko
import asyncio
import os
import sqlite3
import time
import hashlib
import secrets
from contextlib import contextmanager
from dotenv import load_dotenv
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import (
    ApplicationBuilder,
    CommandHandler,
    ContextTypes,
    CallbackQueryHandler,
)

from src.commands.admin_commands.approve import approve_user_command
from src.commands.admin_commands.set_timeout import set_timeout
from src.commands.login import login
from src.commands.logout import logout
from src.commands.register import register
from src.commands.restart import restart
from src.commands.start import start
from src.config import AppConfig, config
from src.db.utils import init_db
from src.handlers.buttons.approve_button import button_approve_handler
from src.handlers.buttons.main_buttons import button_handler
from src.handlers.buttons.settings_buttons import settings_button_handler

# # --- Логирование ---
# logging.basicConfig(
#     format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
#     level=logging.INFO
# )
# logger = logging.getLogger(__name__)
#
# if pathlib.Path.exists(pathlib.Path(".env")):
#     logger.info(".env found, loading...")
#     load_dotenv(".env")
# else:
#     logger.error("File not found, please check your env file")
#     sys.exit(1)

# --- Конфигурация ---
# BOT_TOKEN = os.getenv('TELEGRAM_BOT_TOKEN')
# SSH_HOST = os.getenv('SSH_HOST')
# SSH_PORT = int(os.getenv('SSH_PORT', 22))
# # SSH учётка бота
# BOT_SSH_USER = os.getenv('BOT_SSH_USER')
# BOT_SSH_PASS = os.getenv('BOT_SSH_PASS')
# ADMIN_TELEGRAM_ID = int(os.getenv('ADMIN_TELEGRAM_ID'))
# PASSWORD_HASH_SECRET = os.getenv('PASSWORD_HASH_SECRET')
# # Инициализируем SESSION_TIMEOUT из .env или значением по умолчанию
# SESSION_TIMEOUT = int(os.getenv('SESSION_TIMEOUT', 300)) # По умолчанию 5 минут



# --- Инициализация БД ---
# DB_NAME = "bot_users.db"
#
# def init_db():
#     """Создаёт таблицы пользователей и сессий, если их нет."""
#     with get_db_connection() as conn:
#         cursor = conn.cursor()
#         # Таблица пользователей бота
#         cursor.execute('''
#             CREATE TABLE IF NOT EXISTS bot_users (
#                 id INTEGER PRIMARY KEY AUTOINCREMENT,
#                 telegram_id INTEGER UNIQUE NOT NULL,
#                 username TEXT UNIQUE NOT NULL, -- Внутренний логин в боте
#                 password_hash TEXT NOT NULL, -- Хеш пароля
#                 salt TEXT NOT NULL, -- Соль для хеширования
#                 status TEXT NOT NULL DEFAULT 'pending', -- 'pending', 'active', 'banned'
#                 registered_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
#             )
#         ''')
#         # Таблица активных сессий бота (временно хранит данные пользователя)
#         cursor.execute('''
#             CREATE TABLE IF NOT EXISTS active_sessions (
#                 telegram_id INTEGER PRIMARY KEY,
#                 bot_user_id INTEGER NOT NULL,
#                 timestamp REAL NOT NULL,
#                 FOREIGN KEY (bot_user_id) REFERENCES bot_users (id)
#             )
#         ''')
#         conn.commit()
#         logger.info("База данных инициализирована.")
#
# @contextmanager
# def get_db_connection():
#     """Контекстный менеджер для подключения к БД."""
#     conn = sqlite3.connect(DB_NAME)
#     try:
#         yield conn
#     finally:
#         conn.close()
#
# # --- Функции работы с БД (Пользователи) ---
# def register_bot_user(telegram_id: int, username: str, password: str) -> bool:
#     """Регистрирует нового пользователя бота. Возвращает True, если успешно."""
#     try:
#         salt = secrets.token_hex(16)
#         password_hash = hashlib.pbkdf2_hmac('sha256', password.encode('utf-8'), (PASSWORD_HASH_SECRET + salt).encode('utf-8'), 100000).hex()
#         with get_db_connection() as conn:
#             cursor = conn.cursor()
#             cursor.execute(
#                 "INSERT INTO bot_users (telegram_id, username, password_hash, salt, status) VALUES (?, ?, ?, ?, 'pending')",
#                 (telegram_id, username, password_hash, salt)
#             )
#             conn.commit()
#         return True
#     except sqlite3.IntegrityError as e: # Например, дубликат telegram_id или username
#         logger.warning(f"Ошибка регистрации пользователя {telegram_id}/{username}: {e}")
#         return False
#
# def get_user_status(telegram_id: int) -> str | None:
#     """Получает статус пользователя по Telegram ID."""
#     with get_db_connection() as conn:
#         cursor = conn.cursor()
#         cursor.execute("SELECT status FROM bot_users WHERE telegram_id = ?", (telegram_id,))
#         row = cursor.fetchone()
#         return row[0] if row else None
#
# def approve_user(telegram_id: int):
#     """Одобряет пользователя, меняя статус на 'active'."""
#     with get_db_connection() as conn:
#         cursor = conn.cursor()
#         cursor.execute("UPDATE bot_users SET status = 'active' WHERE telegram_id = ?", (telegram_id,))
#         conn.commit()
#
# def authenticate_user(username: str, password: str) -> tuple[int | None, int | None]:
#     """
#     Аутентифицирует пользователя по логину и паролю.
#     Возвращает (telegram_id, bot_user_id) если успешно, иначе (None, None).
#     """
#     with get_db_connection() as conn:
#         cursor = conn.cursor()
#         cursor.execute("SELECT id, telegram_id, password_hash, salt FROM bot_users WHERE username = ? AND status = 'active'", (username,))
#         row = cursor.fetchone()
#         if row:
#             bot_user_id, telegram_id, stored_hash, salt = row
#             password_hash = hashlib.pbkdf2_hmac('sha256', password.encode('utf-8'), (PASSWORD_HASH_SECRET + salt).encode('utf-8'), 100000).hex()
#             if secrets.compare_digest(password_hash, stored_hash): # Безопасное сравнение
#                 return telegram_id, bot_user_id
#     return None, None
#
# def is_user_active(telegram_id: int) -> bool:
#     """Проверяет, активен ли пользователь по Telegram ID."""
#     status = get_user_status(telegram_id)
#     return status == 'active'
#
# # --- Функции работы с БД (Сессии) ---
# def create_session(telegram_id: int, bot_user_id: int):
#     """Создаёт или обновляет сессию пользователя."""
#     timestamp = time.time()
#     with get_db_connection() as conn:
#         cursor = conn.cursor()
#         cursor.execute(
#             "INSERT OR REPLACE INTO active_sessions (telegram_id, bot_user_id, timestamp) VALUES (?, ?, ?)",
#             (telegram_id, bot_user_id, timestamp)
#         )
#         conn.commit()
#
# def get_session(telegram_id: int) -> tuple[int | None, float | None]:
#     """Получает ID пользователя бота и временную метку сессии. Возвращает (bot_user_id, timestamp) или (None, None)."""
#     with get_db_connection() as conn:
#         cursor = conn.cursor()
#         cursor.execute("SELECT bot_user_id, timestamp FROM active_sessions WHERE telegram_id = ?", (telegram_id,))
#         row = cursor.fetchone()
#         return row if row else (None, None)
#
# def delete_session(telegram_id: int):
#     """Удаляет сессию пользователя."""
#     with get_db_connection() as conn:
#         cursor = conn.cursor()
#         cursor.execute("DELETE FROM active_sessions WHERE telegram_id = ?", (telegram_id,))
#         conn.commit()
#
# def cleanup_expired_sessions():
#     """Удаляет истёкшие сессии из БД."""
#     now = time.time()
#     expired_time = now - SESSION_TIMEOUT
#     with get_db_connection() as conn:
#         cursor = conn.cursor()
#         cursor.execute("DELETE FROM active_sessions WHERE timestamp < ?", (expired_time,))
#         deleted_count = cursor.rowcount
#         conn.commit()
#         if deleted_count > 0:
#             logger.info(f"Удалено {deleted_count} истёкших сессий.")

# --- Функция для завершения сессии на сервере (через SSH) ---
# async def restart_user_session_on_server(target_username: str) -> str:
#     """
#     Подключается по SSH с учёткой бота и завершает сессию пользователя на сервере.
#     """
#     try:
#         ssh = paramiko.SSHClient()
#         ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
#         # Подключение
#         ssh.connect(
#             hostname=SSH_HOST,
#             port=SSH_PORT,
#             username=BOT_SSH_USER,
#             password=BOT_SSH_PASS
#         )
#         # Выполняем команду поиска сессии
#         stdin, stdout, stderr = ssh.exec_command(f'query session {target_username}')
#         # Читаем вывод с правильной кодировкой для Windows (cp866 для русского)
#         output = stdout.read().decode('cp866', errors='ignore').strip()
#         # print(output) # Для отладки
#         error = stderr.read().decode('cp866', errors='ignore').strip()
#         # Логируем для отладки (можно убрать)
#         logger.info(f"Вывод query session для {target_username}:\n{output}")
#         if error:
#             logger.warning(f"STDERR для {target_username}:\n{error}")
#         # Проверка на ошибки
#         if error and not output:
#             ssh.close()
#             return f"❌ Ошибка при поиске сессии: {error}"
#         # Проверка, существует ли пользователь
#         if ("Не существуют сеансы для" in output or
#                 "Нет пользователя" in output or
#                 "The session name is invalid" in output or
#                 "not found" in output.lower()):
#             ssh.close()
#             return f"ℹ️ Пользователь '{target_username}' не найден или не активен."
#         # Разбор строк
#         lines = output.split('\n')
#         if len(lines) < 2:
#             ssh.close()
#             return "❌ Не удалось получить данные о сессии (неполный вывод)."
#         # Берём первую строку с данными о сессии (обычно после заголовка)
#         session_line = ""
#         for line in lines[1:]:
#             line = line.strip()
#             if line and not line.startswith('-'):
#                 session_line = line
#                 break
#         if not session_line:
#             ssh.close()
#             return "❌ Не удалось найти строку с данными о сессии."
#         # Разделяем по пробелам
#         parts = session_line.split()
#         if len(parts) < 3:
#             ssh.close()
#             return f"❌ Ошибка разбора строки сессии: '{session_line}'"
#         # ID сессии — третий элемент
#         session_id = parts[2]
#         # print(parts) # Для отладки
#         # Завершаем сессию
#         stdin, stdout, stderr = ssh.exec_command(f'logoff {session_id}')
#         logoff_error = stderr.read().decode('cp866', errors='ignore').strip()
#         ssh.close()
#         if logoff_error:
#             return f"❌ Ошибка при завершении сессии: {logoff_error}"
#         else:
#             return f"✅ Сессия пользователя '{target_username}' (ID: {session_id}) успешно завершена."
#     except Exception as e:
#         logger.error(f"Ошибка SSH: {e}")
#         return f"❌ Произошла ошибка: {str(e)}"

# --- Функция для создания главного меню ---
# def get_main_menu(is_logged_in: bool = False, is_admin: bool = False):
#     keyboard = []
#     if not is_logged_in:
#         keyboard.append([InlineKeyboardButton("🔑 Войти", callback_data='login')])
#         keyboard.append([InlineKeyboardButton("📝 Зарегистрироваться", callback_data='register')])
#     else:
#         keyboard.append([InlineKeyboardButton("🔄 Перезапустить сессию", callback_data='restart')])
#         keyboard.append([InlineKeyboardButton("🚪 Выйти", callback_data='logout')])
#
#     # Добавляем кнопку настроек только для администратора
#     if is_admin:
#         keyboard.append([InlineKeyboardButton("⚙️ Настройки", callback_data='settings')])
#
#     return InlineKeyboardMarkup(keyboard)

# # --- Функция для создания меню настроек ---
# def get_settings_menu():
#     keyboard = [
#         [InlineKeyboardButton(f"⏱️ Таймаут сессии: {SESSION_TIMEOUT} сек", callback_data='dummy_info')], # Информационная кнопка
#         [InlineKeyboardButton("✏️ Изменить таймаут", callback_data='change_timeout')],
#         [InlineKeyboardButton("⬅️ Назад", callback_data='back_to_main')],
#     ]
#     return InlineKeyboardMarkup(keyboard)

# --- Функция для обновления основного сообщения ---
# async def update_main_message(update: Update, context: ContextTypes.DEFAULT_TYPE, status_text: str, is_logged_in: bool = False):
#     """Обновляет основное сообщение бота с новым статусом и меню."""
#     user_id = update.effective_user.id
#     is_admin = (user_id == ADMIN_TELEGRAM_ID)
#     menu_markup = get_main_menu(is_logged_in, is_admin)
#
#     # Получаем chat_id и message_id из context.user_data или update
#     chat_id = context.user_data.get('main_menu_chat_id') or update.effective_chat.id
#     message_id = context.user_data.get('main_menu_message_id')
#
#     # Если message_id известен, пытаемся отредактировать сообщение
#     if message_id:
#         try:
#             await context.bot.edit_message_text(
#                 chat_id=chat_id,
#                 message_id=message_id,
#                 text=status_text,
#                 reply_markup=menu_markup,
#                 parse_mode='Markdown'
#             )
#             logger.debug(f"Сообщение {message_id} в чате {chat_id} отредактировано.")
#             return # Успешно отредактировали, выходим
#         except Exception as e:
#             error_message = str(e).lower()
#             if "message to edit not found" in error_message or "message_id_invalid" in error_message or "message not found" in error_message:
#                 logger.warning(f"Основное сообщение {message_id} не найдено. Отправляем новое.")
#                 # Удаляем устаревшие данные
#                 context.user_data.pop('main_menu_message_id', None)
#                 context.user_data.pop('main_menu_chat_id', None)
#                 message_id = None # Сбросим message_id, чтобы отправить новое сообщение
#             else:
#                 logger.error(f"Ошибка редактирования основного сообщения {message_id}: {e}")
#                 # Даже при ошибке редактирования, не отправляем новое сообщение, если message_id был
#                 return
#
#     # Если message_id неизвестен или сообщение не найдено, отправляем новое
#     # Это происходит при первом запуске или после очистки истории
#     try:
#         sent_message = await context.bot.send_message(
#             chat_id=chat_id,
#             text=status_text,
#             reply_markup=menu_markup,
#             parse_mode='Markdown'
#         )
#         # Сохраняем ID нового сообщения
#         context.user_data['main_menu_message_id'] = sent_message.message_id
#         context.user_data['main_menu_chat_id'] = sent_message.chat_id
#         logger.info(f"Новое основное сообщение {sent_message.message_id} отправлено в чат {sent_message.chat_id}.")
#     except Exception as e:
#         logger.error(f"Ошибка отправки нового основного сообщения: {e}")


# # --- Обработчики команд ---
# async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
#     user_id = update.effective_user.id
#     is_admin = (user_id == ADMIN_TELEGRAM_ID)
#     # Проверяем, есть ли активная сессия
#     bot_user_id, timestamp = get_session(user_id)
#     is_logged_in = bot_user_id is not None and (time.time() - timestamp) < SESSION_TIMEOUT
#     if is_logged_in:
#         welcome_text = "👋 *Привет!* Вы уже вошли в систему."
#     else:
#         welcome_text = "👋 *Привет!* Я бот для перезапуска сессий пользователей.\n\nИспользуйте кнопки ниже для навигации."
#
#     # Удаляем сообщение /start
#     try:
#         await context.bot.delete_message(chat_id=update.effective_chat.id, message_id=update.effective_message.message_id)
#         logger.debug(f"Сообщение /start от пользователя {user_id} удалено.")
#     except Exception as e:
#         logger.warning(f"Не удалось удалить сообщение /start {update.effective_message.message_id}: {e}")
#
#     # Отправляем основное сообщение
#     await update_main_message(update, context, welcome_text, is_logged_in)

# async def button_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
#     """Обработчик нажатий на основные кнопки"""
#     query = update.callback_query
#     await query.answer()
#     user_id = query.from_user.id
#     data = query.data
#     is_admin = (user_id == ADMIN_TELEGRAM_ID)
#     # Очистка истёкших сессий
#     cleanup_expired_sessions()
#
#     # Проверяем сессию пользователя
#     bot_user_id, timestamp = get_session(user_id)
#     is_logged_in = bot_user_id is not None and (time.time() - timestamp) < SESSION_TIMEOUT
#
#     if data == 'register':
#         status_text = (
#             "📝 *Регистрация*\n\n"
#             "Пожалуйста, введите данные для регистрации в формате:\n"
#             "`/register <внутренний_логин> <пароль>`\n\n"
#             "*Важно:* Этот логин/пароль будет использоваться только для входа в *этот бот* и не связан с вашей учеткой на сервере."
#         )
#         await update_main_message(update, context, status_text, is_logged_in=False) # После нажатия "Регистрация" пользователь точно не залогинен
#
#     elif data == 'login':
#         # Проверка, если пользователь уже залогинен (по сессии)
#         if is_logged_in:
#              # Обновляем таймаут
#              create_session(user_id, bot_user_id)
#              status_text = "✅ Вы уже вошли в систему."
#              await update_main_message(update, context, status_text, is_logged_in=True)
#         else:
#             status_text = (
#                 "🔑 *Вход*\n\n"
#                 "Пожалуйста, введите логин и пароль в формате:\n"
#                 "`/login <внутренний_логин> <пароль>`"
#             )
#             await update_main_message(update, context, status_text, is_logged_in=False)
#
#     elif data == 'restart':
#         if not is_logged_in:
#             status_text = "❌ Сначала авторизуйтесь."
#             await update_main_message(update, context, status_text, is_logged_in=False)
#             return
#         # Обновляем таймаут
#         create_session(user_id, bot_user_id)
#         status_text = (
#             "🔄 *Перезапуск сессии*\n\n"
#             "Введите имя пользователя на сервере для перезапуска сессии:\n"
#             "`/restart <имя_пользователя_на_сервере>`"
#         )
#         await update_main_message(update, context, status_text, is_logged_in=True)
#
#     elif data == 'logout':
#         delete_session(user_id)
#         status_text = "✅ Вы вышли из системы."
#         await update_main_message(update, context, status_text, is_logged_in=False) # Не залогинен
#
#     elif data == 'settings':
#         if not is_admin:
#             await query.answer("❌ У вас нет прав для доступа к настройкам.", show_alert=True)
#             # Обновляем основное сообщение, чтобы убрать потенциальное сообщение об ошибке
#             # await update_main_message(update, context, "❌ Доступ запрещён.", is_logged_in=is_logged_in)
#             return
#         # Переход в меню настроек
#         settings_text = f"⚙️ *Настройки бота*\n\nТекущие параметры:"
#         # Получаем chat_id и message_id из context.user_data или update
#         chat_id = context.user_data.get('main_menu_chat_id') or update.effective_chat.id
#         message_id = context.user_data.get('main_menu_message_id') or query.message.message_id
#
#         try:
#             await context.bot.edit_message_text(
#                 chat_id=chat_id,
#                 message_id=message_id,
#                 text=settings_text,
#                 parse_mode='Markdown',
#                 reply_markup=get_settings_menu()
#             )
#         except Exception as e:
#              logger.error(f"Ошибка редактирования сообщения для перехода в настройки: {e}")
#              # Если не удалось отредактировать, отправляем новое
#              try:
#                  sent_message = await context.bot.send_message(
#                      chat_id=chat_id,
#                      text=settings_text,
#                      reply_markup=get_settings_menu(),
#                      parse_mode='Markdown'
#                  )
#                  context.user_data['main_menu_message_id'] = sent_message.message_id
#                  context.user_data['main_menu_chat_id'] = sent_message.chat_id
#              except Exception as e2:
#                  logger.error(f"Ошибка отправки нового сообщения настроек: {e2}")

# async def settings_button_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
#     """Обработчик нажатий на кнопки внутри меню настроек"""
#     query = update.callback_query
#     await query.answer()
#     user_id = query.from_user.id
#
#     if user_id != ADMIN_TELEGRAM_ID:
#         await query.answer("❌ У вас нет прав.", show_alert=True)
#         return
#
#     data = query.data
#
#     if data == 'change_timeout':
#         # Предлагаем ввести новое значение
#         instruction_text = (
#             f"⏱️ *Изменение таймаута сессии*\n\n"
#             f"Текущее значение: `{SESSION_TIMEOUT}` секунд.\n"
#             f"Введите новое значение в секундах командой:\n"
#             f"`/set_timeout <значение>`"
#         )
#         # Получаем chat_id и message_id из context.user_data или update
#         chat_id = context.user_data.get('main_menu_chat_id') or update.effective_chat.id
#         message_id = context.user_data.get('main_menu_message_id') or query.message.message_id
#
#         try:
#             await context.bot.edit_message_text(
#                 chat_id=chat_id,
#                 message_id=message_id,
#                 text=instruction_text,
#                 parse_mode='Markdown',
#                 reply_markup=get_settings_menu() # Можно оставить меню, чтобы пользователь мог вернуться
#             )
#         except Exception as e:
#              logger.error(f"Ошибка редактирования сообщения для изменения таймаута: {e}")
#              # Если не удалось отредактировать, отправляем новое
#              try:
#                  sent_message = await context.bot.send_message(
#                      chat_id=chat_id,
#                      text=instruction_text,
#                      reply_markup=get_settings_menu(),
#                      parse_mode='Markdown'
#                  )
#                  context.user_data['main_menu_message_id'] = sent_message.message_id
#                  context.user_data['main_menu_chat_id'] = sent_message.chat_id
#              except Exception as e2:
#                  logger.error(f"Ошибка отправки нового сообщения изменения таймаута: {e2}")
#
#     elif data == 'back_to_main':
#         # Возврат в главное меню
#         # Нужно определить статус админа и залогиненности
#         bot_user_id, timestamp = get_session(user_id)
#         is_logged_in = bot_user_id is not None and (time.time() - timestamp) < SESSION_TIMEOUT
#         is_admin = (user_id == ADMIN_TELEGRAM_ID)
#         main_text = "⬅️ *Главное меню*"
#         if is_logged_in:
#             main_text += "\n\n✅ Вы вошли в систему."
#         # Получаем chat_id и message_id из context.user_data или update
#         chat_id = context.user_data.get('main_menu_chat_id') or update.effective_chat.id
#         message_id = context.user_data.get('main_menu_message_id') or query.message.message_id
#
#         try:
#             await context.bot.edit_message_text(
#                 chat_id=chat_id,
#                 message_id=message_id,
#                 text=main_text,
#                 parse_mode='Markdown',
#                 reply_markup=get_main_menu(is_logged_in, is_admin)
#             )
#         except Exception as e:
#              logger.error(f"Ошибка редактирования сообщения для возврата в главное меню: {e}")
#              # Если не удалось отредактировать, отправляем новое
#              try:
#                  sent_message = await context.bot.send_message(
#                      chat_id=chat_id,
#                      text=main_text,
#                      reply_markup=get_main_menu(is_logged_in, is_admin),
#                      parse_mode='Markdown'
#                  )
#                  context.user_data['main_menu_message_id'] = sent_message.message_id
#                  context.user_data['main_menu_chat_id'] = sent_message.chat_id
#              except Exception as e2:
#                  logger.error(f"Ошибка отправки нового сообщения главного меню: {e2}")
#
#     elif data == 'dummy_info':
#         # Информационная кнопка, ничего не делает
#         await query.answer("Это информационное поле.", show_alert=False)

# --- Обработчики команд администратора ---
# async def set_timeout(update: Update, context: ContextTypes.DEFAULT_TYPE):
#     """Команда /set_timeout <значение> для админа"""
#     user_id = update.effective_user.id
#     chat_id = update.effective_chat.id
#     message_id = update.effective_message.message_id
#     global SESSION_TIMEOUT
#
#     if user_id != ADMIN_TELEGRAM_ID:
#         response_text = "❌ У вас нет прав для изменения настроек."
#         # Отправляем ответ админу в основном сообщении
#         bot_user_id, timestamp = get_session(user_id)
#         is_logged_in = bot_user_id is not None and (time.time() - timestamp) < SESSION_TIMEOUT
#         is_admin_user = (user_id == ADMIN_TELEGRAM_ID)
#         await update_main_message(update, context, response_text, is_logged_in)
#         try:
#              await context.bot.delete_message(chat_id=chat_id, message_id=message_id)
#              logger.debug(f"Сообщение /set_timeout от пользователя {user_id} удалено.")
#         except Exception as e:
#              logger.warning(f"Не удалось удалить сообщение /set_timeout {message_id}: {e}")
#         return
#
#     if not context.args or not context.args[0].isdigit():
#         response_text = "Используйте: `/set_timeout <значение_в_секундах>`"
#         # Отправляем ответ админу в основном сообщении
#         bot_user_id, timestamp = get_session(user_id)
#         is_logged_in = bot_user_id is not None and (time.time() - timestamp) < SESSION_TIMEOUT
#         is_admin_user = (user_id == ADMIN_TELEGRAM_ID)
#         await update_main_message(update, context, response_text, is_logged_in)
#         try:
#              await context.bot.delete_message(chat_id=chat_id, message_id=message_id)
#              logger.debug(f"Сообщение /set_timeout от пользователя {user_id} удалено.")
#         except Exception as e:
#              logger.warning(f"Не удалось удалить сообщение /set_timeout {message_id}: {e}")
#         return
#
#
#     new_timeout = int(context.args[0])
#     if new_timeout <= 0:
#         response_text = "❌ Значение таймаута должно быть положительным числом."
#         # Отправляем ответ админу в основном сообщении
#         bot_user_id, timestamp = get_session(user_id)
#         is_logged_in = bot_user_id is not None and (time.time() - timestamp) < SESSION_TIMEOUT
#         is_admin_user = (user_id == ADMIN_TELEGRAM_ID)
#         await update_main_message(update, context, response_text, is_logged_in)
#         try:
#              await context.bot.delete_message(chat_id=chat_id, message_id=message_id)
#              logger.debug(f"Сообщение /set_timeout от пользователя {user_id} удалено.")
#         except Exception as e:
#              logger.warning(f"Не удалось удалить сообщение /set_timeout {message_id}: {e}")
#         return
#
#     old_timeout = SESSION_TIMEOUT
#     SESSION_TIMEOUT = new_timeout
#
#     response_text = f"✅ Таймаут сессии изменён с {old_timeout} сек на {new_timeout} сек."
#
#     # Удаляем сообщение с командой
#     try:
#         await context.bot.delete_message(chat_id=chat_id, message_id=message_id)
#         logger.info(f"Сообщение /set_timeout от админа {user_id} удалено.")
#     except Exception as e:
#         logger.warning(f"Не удалось удалить сообщение /set_timeout {message_id}: {e}")
#
#     # Отправляем подтверждение в основном сообщении и возвращаем в меню настроек
#     # Получаем chat_id и message_id из context.user_data или update
#     main_chat_id = context.user_data.get('main_menu_chat_id') or chat_id
#     main_message_id = context.user_data.get('main_menu_message_id')
#
#     if main_message_id:
#         try:
#             await context.bot.edit_message_text(
#                 chat_id=main_chat_id,
#                 message_id=main_message_id,
#                 text=response_text + "\n\nВозвращаюсь в настройки...",
#                 parse_mode='Markdown'
#             )
#             # Небольшая задержка перед возвратом в меню настроек
#             await asyncio.sleep(1.5)
#             await context.bot.edit_message_text(
#                 chat_id=main_chat_id,
#                 message_id=main_message_id,
#                 text="⚙️ *Настройки бота*\n\nТекущие параметры:",
#                 parse_mode='Markdown',
#                 reply_markup=get_settings_menu()
#             )
#         except Exception as e:
#              logger.error(f"Ошибка обновления основного сообщения после set_timeout: {e}")
#              # Если не удалось отредактировать, отправляем новое
#              try:
#                  sent_message = await context.bot.send_message(
#                      chat_id=main_chat_id,
#                      text="⚙️ *Настройки бота*\n\nТекущие параметры:",
#                      reply_markup=get_settings_menu(),
#                      parse_mode='Markdown'
#                  )
#                  context.user_data['main_menu_message_id'] = sent_message.message_id
#                  context.user_data['main_menu_chat_id'] = sent_message.chat_id
#              except Exception as e2:
#                  logger.error(f"Ошибка отправки нового сообщения настроек после set_timeout: {e2}")
#     else:
#         # Если основное сообщение не найдено, отправляем новое
#         try:
#              sent_message = await context.bot.send_message(
#                  chat_id=main_chat_id,
#                  text="⚙️ *Настройки бота*\n\nТекущие параметры:",
#                  reply_markup=get_settings_menu(),
#                  parse_mode='Markdown'
#              )
#              context.user_data['main_menu_message_id'] = sent_message.message_id
#              context.user_data['main_menu_chat_id'] = sent_message.chat_id
#         except Exception as e:
#              logger.error(f"Ошибка отправки нового сообщения настроек после set_timeout (нет основного): {e}")

# --- Остальные обработчики команд ---
# async def register(update: Update, context: ContextTypes.DEFAULT_TYPE):
#     user_id = update.effective_user.id
#     chat_id = update.effective_chat.id
#     message_id = update.effective_message.message_id
#
#     # Проверка, не зарегистрирован ли уже пользователь
#     with get_db_connection() as conn:
#         cursor = conn.cursor()
#         cursor.execute("SELECT status FROM bot_users WHERE telegram_id = ?", (user_id,))
#         existing_user = cursor.fetchone()
#
#     if existing_user:
#         status = existing_user[0]
#         if status == 'active':
#             status_text = "✅ Вы уже зарегистрированы и одобрены."
#         elif status == 'pending':
#             status_text = "⏳ Ваша заявка на регистрацию ожидает одобрения администратора."
#         else: # banned
#              status_text = "ℹ️ Ваша регистрация заблокирована."
#         # Удаляем исходное сообщение пользователя
#         try:
#              await context.bot.delete_message(chat_id=chat_id, message_id=message_id)
#              logger.debug(f"Сообщение /register от пользователя {user_id} удалено.")
#         except Exception as e:
#              logger.warning(f"Не удалось удалить сообщение /register {message_id}: {e}")
#         await update_main_message(update, context, status_text, is_logged_in=False) # Предполагаем, что при регистрации он не залогинен
#         return
#
#     if len(context.args) < 2:
#         status_text = (
#             "📝 *Регистрация*\n\n"
#             "Используйте: `/register <внутренний_логин> <пароль>`\n\n"
#             "*Важно:* Этот логин/пароль будет использоваться только для входа в *этот бот* и не связан с вашей учеткой на сервере."
#         )
#         # Удаляем исходное сообщение пользователя
#         try:
#              await context.bot.delete_message(chat_id=chat_id, message_id=message_id)
#              logger.debug(f"Сообщение /register от пользователя {user_id} удалено.")
#         except Exception as e:
#              logger.warning(f"Не удалось удалить сообщение /register {message_id}: {e}")
#         await update_main_message(update, context, status_text, is_logged_in=False)
#         return
#
#     username = context.args[0].strip()
#     password = context.args[1]
#
#     if register_bot_user(user_id, username, password):
#         status_text = "✅ Регистрация прошла успешно. Ожидайте одобрения администратора."
#         # Уведомляем админа (отдельным сообщением, как и было)
#         approve_button = InlineKeyboardButton("✅ Одобрить", callback_data=f'approve_{user_id}')
#         keyboard = [[approve_button]]
#         reply_markup = InlineKeyboardMarkup(keyboard)
#         try:
#             await context.bot.send_message(
#                 chat_id=ADMIN_TELEGRAM_ID,
#                 text=f"🔔 Новая заявка на регистрацию!\nTelegram User ID: `{user_id}`\nИмя: {update.effective_user.full_name or 'N/A'}\nUsername: @{update.effective_user.username or 'N/A'}\nВнутренний логин: `{username}`",
#                 parse_mode='Markdown',
#                 reply_markup=reply_markup
#             )
#         except Exception as e:
#              logger.error(f"Не удалось уведомить администратора: {e}")
#         logger.info(f"Новая заявка на регистрацию от пользователя {user_id} (внутр. логин: {username})")
#     else:
#         status_text = "❌ Ошибка регистрации. Возможно, логин уже занят."
#
#     # Удаляем исходное сообщение пользователя
#     try:
#         await context.bot.delete_message(chat_id=chat_id, message_id=message_id)
#         logger.debug(f"Сообщение /register от пользователя {user_id} удалено.")
#     except Exception as e:
#         logger.warning(f"Не удалось удалить сообщение /register {message_id}: {e}")
#
#     await update_main_message(update, context, status_text, is_logged_in=False)

# async def approve_user_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
#     """Обрабатывает команду /approve <user_id> от админа."""
#     user_id = update.effective_user.id
#     chat_id = update.effective_chat.id
#     message_id = update.effective_message.message_id
#
#     if user_id != ADMIN_TELEGRAM_ID:
#         status_text = "❌ У вас нет прав для одобрения пользователей."
#         # Отправляем ответ админу в основном сообщении
#         bot_user_id, timestamp = get_session(user_id)
#         is_logged_in = bot_user_id is not None and (time.time() - timestamp) < SESSION_TIMEOUT
#         is_admin_user = (user_id == ADMIN_TELEGRAM_ID)
#         await update_main_message(update, context, status_text, is_logged_in)
#         try:
#              await context.bot.delete_message(chat_id=chat_id, message_id=message_id)
#              logger.debug(f"Сообщение /approve от пользователя {user_id} удалено.")
#         except Exception as e:
#              logger.warning(f"Не удалось удалить сообщение /approve {message_id}: {e}")
#         return
#
#     if not context.args or not context.args[0].isdigit():
#         status_text = "Используйте: `/approve <telegram_user_id>`"
#         # Отправляем ответ админу в основном сообщении
#         bot_user_id, timestamp = get_session(user_id)
#         is_logged_in = bot_user_id is not None and (time.time() - timestamp) < SESSION_TIMEOUT
#         is_admin_user = (user_id == ADMIN_TELEGRAM_ID)
#         await update_main_message(update, context, status_text, is_logged_in)
#         try:
#              await context.bot.delete_message(chat_id=chat_id, message_id=message_id)
#              logger.debug(f"Сообщение /approve от пользователя {user_id} удалено.")
#         except Exception as e:
#              logger.warning(f"Не удалось удалить сообщение /approve {message_id}: {e}")
#         return
#
#     target_telegram_id = int(context.args[0])
#     with get_db_connection() as conn:
#         cursor = conn.cursor()
#         cursor.execute("SELECT status FROM bot_users WHERE telegram_id = ?", (target_telegram_id,))
#         row = cursor.fetchone()
#
#     if not row:
#         status_text = f"❌ Пользователь с Telegram ID {target_telegram_id} не найден в заявках."
#         # Отправляем ответ админу в основном сообщении
#         bot_user_id, timestamp = get_session(user_id)
#         is_logged_in = bot_user_id is not None and (time.time() - timestamp) < SESSION_TIMEOUT
#         is_admin_user = (user_id == ADMIN_TELEGRAM_ID)
#         await update_main_message(update, context, status_text, is_logged_in)
#         try:
#              await context.bot.delete_message(chat_id=chat_id, message_id=message_id)
#              logger.debug(f"Сообщение /approve от пользователя {user_id} удалено.")
#         except Exception as e:
#              logger.warning(f"Не удалось удалить сообщение /approve {message_id}: {e}")
#         return
#
#     current_status = row[0]
#     if current_status == 'active':
#         status_text = f"ℹ️ Пользователь {target_telegram_id} уже одобрен."
#     elif current_status in ['pending', 'banned']:
#         approve_user(target_telegram_id)
#         status_text = f"✅ Пользователь {target_telegram_id} одобрен."
#         try:
#             # Уведомляем пользователя об одобрении (отдельным сообщением)
#             await context.bot.send_message(
#                 chat_id=target_telegram_id,
#                 text="🎉 Ваша заявка одобрена! Теперь вы можете войти в бота.",
#                 reply_markup=get_main_menu(is_logged_in=False) # Пользователь еще не залогинен
#             )
#         except Exception as e:
#             logger.warning(f"Не удалось уведомить пользователя {target_telegram_id} об одобрении: {e}")
#     else:
#         status_text = f"❌ Невозможно одобрить пользователя со статусом {current_status}."
#
#     # Удаляем исходное сообщение пользователя
#     try:
#         await context.bot.delete_message(chat_id=chat_id, message_id=message_id)
#         logger.debug(f"Сообщение /approve от админа {user_id} удалено.")
#     except Exception as e:
#         logger.warning(f"Не удалось удалить сообщение /approve {message_id}: {e}")
#
#     # Отправляем ответ админу в основном сообщении
#     bot_user_id, timestamp = get_session(user_id)
#     is_logged_in_admin = bot_user_id is not None and (time.time() - timestamp) < SESSION_TIMEOUT
#     is_admin_user = (user_id == ADMIN_TELEGRAM_ID)
#     await update_main_message(update, context, status_text, is_logged_in_admin)

# async def button_approve_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
#     """Обрабатывает нажатие кнопки 'Одобрить' админом."""
#     query = update.callback_query
#     await query.answer()
#     admin_id = query.from_user.id
#
#     if admin_id != ADMIN_TELEGRAM_ID:
#         await query.answer("❌ У вас нет прав для одобрения.", show_alert=True)
#         return
#
#     data = query.data
#     if data.startswith('approve_'):
#         target_telegram_id = int(data.split('_')[1])
#         with get_db_connection() as conn:
#             cursor = conn.cursor()
#             cursor.execute("SELECT status FROM bot_users WHERE telegram_id = ?", (target_telegram_id,))
#             row = cursor.fetchone()
#
#         if not row:
#              status_text = f"❌ Пользователь {target_telegram_id} не найден."
#              # Редактируем сообщение админа
#              is_admin_logged_in = get_session(admin_id)[0] is not None and (time.time() - get_session(admin_id)[1]) < SESSION_TIMEOUT
#              menu_markup = get_main_menu(is_logged_in=is_admin_logged_in, is_admin=True)
#              await query.edit_message_text(text=status_text, reply_markup=menu_markup)
#              return
#
#         current_status = row[0]
#         if current_status == 'active':
#             status_text = f"ℹ️ Пользователь {target_telegram_id} уже одобрен."
#         elif current_status in ['pending', 'banned']:
#             approve_user(target_telegram_id)
#             status_text = f"✅ Пользователь {target_telegram_id} одобрен через кнопку."
#             try:
#                 # Уведомляем пользователя об одобрении (отдельным сообщением)
#                 await context.bot.send_message(
#                     chat_id=target_telegram_id,
#                     text="🎉 Ваша заявка одобрена! Теперь вы можете войти в бота.",
#                     reply_markup=get_main_menu(is_logged_in=False) # Пользователь еще не залогинен
#                 )
#             except Exception as e:
#                  logger.warning(f"Не удалось уведомить пользователя {target_telegram_id} об одобрении через кнопку: {e}")
#         else:
#              status_text = f"❌ Невозможно одобрить пользователя со статусом {current_status}."
#
#         # Редактируем сообщение админа
#         is_admin_logged_in = get_session(admin_id)[0] is not None and (time.time() - get_session(admin_id)[1]) < SESSION_TIMEOUT
#         menu_markup = get_main_menu(is_logged_in=is_admin_logged_in, is_admin=True)
#         await query.edit_message_text(text=status_text, reply_markup=menu_markup)

# async def login(update: Update, context: ContextTypes.DEFAULT_TYPE):
#     user_id = update.effective_user.id
#     chat_id = update.effective_chat.id
#     message_id = update.effective_message.message_id
#     # Очистка истёкших сессий
#     cleanup_expired_sessions()
#
#     # Проверка, если пользователь уже залогинен (по сессии)
#     bot_user_id, timestamp = get_session(user_id)
#     is_logged_in = bot_user_id is not None and (time.time() - timestamp) < SESSION_TIMEOUT
#     if is_logged_in:
#         # Обновляем таймаут
#         create_session(user_id, bot_user_id)
#         status_text = "✅ Вы уже вошли в систему."
#         # Удаляем исходное сообщение пользователя
#         try:
#              await context.bot.delete_message(chat_id=chat_id, message_id=message_id)
#              logger.debug(f"Сообщение /login от пользователя {user_id} удалено.")
#         except Exception as e:
#              logger.warning(f"Не удалось удалить сообщение /login {message_id}: {e}")
#         await update_main_message(update, context, status_text, is_logged_in=True)
#         return
#
#     if len(context.args) < 2:
#         status_text = (
#             "🔑 *Вход*\n\n"
#             "Используйте: `/login <внутренний_логин> <пароль>`"
#         )
#         # Удаляем исходное сообщение пользователя
#         try:
#              await context.bot.delete_message(chat_id=chat_id, message_id=message_id)
#              logger.debug(f"Сообщение /login от пользователя {user_id} удалено.")
#         except Exception as e:
#              logger.warning(f"Не удалось удалить сообщение /login {message_id}: {e}")
#         await update_main_message(update, context, status_text, is_logged_in=False)
#         return
#
#     username = context.args[0].strip()
#     password = context.args[1]
#     # Проверка учётных данных
#     authenticated_telegram_id, authenticated_bot_user_id = authenticate_user(username, password)
#     if authenticated_telegram_id is not None and authenticated_telegram_id == user_id:
#         # Успешная аутентификация и проверка Telegram ID
#         create_session(user_id, authenticated_bot_user_id) # Создаем или обновляем сессию
#         status_text = f"✅ Вы вошли как `{username}`."
#         is_logged_in = True
#         logger.info(f"Пользователь {user_id} успешно вошёл как {username}")
#     elif authenticated_telegram_id is not None and authenticated_telegram_id != user_id:
#         # Правильный логин/пароль, но другой Telegram ID
#         status_text = "❌ Эта учетная запись привязана к другому аккаунту Telegram."
#         is_logged_in = False
#         logger.warning(f"Попытка входа под чужой учеткой: Telegram ID {user_id} пытался войти как {username} (владелец: {authenticated_telegram_id})")
#     else:
#         # Неверный логин или пароль
#         status_text = "❌ Неверный логин или пароль."
#         is_logged_in = False
#         logger.warning(f"Ошибка входа для пользователя {user_id} с логином {username}")
#
#     # Удаляем исходное сообщение пользователя
#     try:
#         await context.bot.delete_message(chat_id=chat_id, message_id=message_id)
#         logger.debug(f"Сообщение /login от пользователя {user_id} удалено.")
#     except Exception as e:
#         logger.warning(f"Не удалось удалить сообщение /login {message_id}: {e}")
#
#     await update_main_message(update, context, status_text, is_logged_in)

# async def restart(update: Update, context: ContextTypes.DEFAULT_TYPE):
#      user_id = update.effective_user.id
#      chat_id = update.effective_chat.id
#      message_id = update.effective_message.message_id
#      # Очистка истёкших сессий
#      cleanup_expired_sessions()
#
#      # Проверка наличия активной сессии
#      bot_user_id, timestamp = get_session(user_id)
#      is_logged_in = bot_user_id is not None and (time.time() - timestamp) < SESSION_TIMEOUT
#      if not is_logged_in:
#          status_text = "❌ Сначала авторизуйтесь."
#          # Удаляем исходное сообщение пользователя
#          try:
#               await context.bot.delete_message(chat_id=chat_id, message_id=message_id)
#               logger.debug(f"Сообщение /restart от пользователя {user_id} удалено.")
#          except Exception as e:
#               logger.warning(f"Не удалось удалить сообщение /restart {message_id}: {e}")
#          await update_main_message(update, context, status_text, is_logged_in=False)
#          return
#
#      # Обновляем таймаут сессии
#      create_session(user_id, bot_user_id)
#
#      if not context.args:
#          status_text = (
#              "🔄 *Перезапуск сессии*\n\n"
#              "Пожалуйста, укажите имя пользователя на сервере:\n"
#              "`/restart <имя_пользователя_на_сервере>`"
#          )
#          # Удаляем исходное сообщение пользователя
#          try:
#               await context.bot.delete_message(chat_id=chat_id, message_id=message_id)
#               logger.debug(f"Сообщение /restart от пользователя {user_id} удалено.")
#          except Exception as e:
#               logger.warning(f"Не удалось удалить сообщение /restart {message_id}: {e}")
#          await update_main_message(update, context, status_text, is_logged_in=True)
#          return
#
#      target_username = context.args[0].strip()
#
#      # Отправляем промежуточный статус "обрабатывается" как временное сообщение
#      # Это отдельное сообщение, не основное.
#      try:
#          status_message = await update.message.reply_text(f"🔄 Перезапускаю сессию для '{target_username}' на сервере...")
#      except Exception as e:
#          logger.error(f"Ошибка отправки временного сообщения статуса: {e}")
#          status_message = None
#
#      # Выполняем SSH в отдельном потоке
#      loop = asyncio.get_event_loop()
#      result = await loop.run_in_executor(
#          None,
#          lambda username: asyncio.run(restart_user_session_on_server(username)),
#          target_username
#      )
#
#      # Редактируем временное сообщение с результатом
#      if status_message:
#          try:
#              # Редактируем временное сообщение
#              await status_message.edit_text(result)
#              # Удаляем временное сообщение после небольшой задержки (опционально)
#              # await asyncio.sleep(5)
#              # await context.bot.delete_message(chat_id=status_message.chat_id, message_id=status_message.message_id)
#          except Exception as e:
#               logger.error(f"Ошибка редактирования временного сообщения статуса: {e}")
#
#      # Обновляем основное сообщение с результатом или информацией о следующем шаге
#      # Предполагаем, что пользователь захочет сделать еще что-то, показываем меню.
#      await update_main_message(update, context, result + "\n\nВыберите следующее действие:", is_logged_in=True)
#
#      # Удаляем исходное сообщение пользователя с командой
#      try:
#           await context.bot.delete_message(chat_id=chat_id, message_id=message_id)
#           logger.info(f"Сообщение /restart от пользователя {user_id} удалено.")
#      except Exception as e:
#           logger.warning(f"Не удалось удалить сообщение /restart {message_id}: {e}")

# async def logout(update: Update, context: ContextTypes.DEFAULT_TYPE):
#     user_id = update.effective_user.id
#     chat_id = update.effective_chat.id
#     message_id = update.effective_message.message_id
#     delete_session(user_id) # Удаляем сессию
#     status_text = "✅ Вы вышли из системы."
#     # Удаляем исходное сообщение пользователя
#     try:
#         await context.bot.delete_message(chat_id=chat_id, message_id=message_id)
#         logger.debug(f"Сообщение /logout от пользователя {user_id} удалено.")
#     except Exception as e:
#         logger.warning(f"Не удалось удалить сообщение /logout {message_id}: {e}")
#     await update_main_message(update, context, status_text, is_logged_in=False)